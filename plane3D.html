<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ÁêâÁêÉ‰πãÊàò 3D - J20 Remaster</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; touch-action: none; display: flex; justify-content: center; align-items: center; height: 100vh; font-family: "Microsoft YaHei", sans-serif; user-select: none; -webkit-user-select: none; }
        #gameContainer { position: relative; width: 100%; max-width: 600px; height: 100%; background: #000; box-shadow: 0 0 50px #001; }
        /* 3D Canvas */
        #gameCanvas { width: 100%; height: 100%; display: block; outline: none; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 20; color: white; backdrop-filter: blur(4px); transition: opacity 0.4s; pointer-events: auto; }
        .hidden { opacity: 0; pointer-events: none; }
        h1 { font-size: 56px; margin: 0 0 10px 0; background: linear-gradient(to bottom, #ff3333, #ffcc00); -webkit-background-clip: text; -webkit-text-fill-color: transparent; font-weight: 900; letter-spacing: 4px; text-shadow: 0 5px 20px rgba(255, 0, 0, 0.5); filter: drop-shadow(0 0 5px rgba(255,200,0,0.5)); text-align: center;}
        .hud { position: absolute; top: 15px; left: 15px; width: 90%; display: flex; justify-content: space-between; color: #fff; font-weight: 800; font-size: 14px; z-index: 5; text-shadow: 1px 1px 2px #000; pointer-events: none; }
        .boss-hp-bar { position: absolute; top: 50px; left: 10%; width: 80%; height: 10px; background: #333; border: 1px solid #fff; display: none; box-shadow: 0 0 10px #f00; z-index: 5;}
        .boss-hp-fill { width: 100%; height: 100%; background: #f00; transition: width 0.1s; }
        #studioLogo { position: absolute; bottom: 15px; width: 100%; text-align: center; color: rgba(255, 255, 255, 0.4); font-size: 12px; font-weight: bold; letter-spacing: 2px; pointer-events: none; z-index: 2; font-family: 'Segoe UI', monospace; animation: breathe 4s infinite ease-in-out; }
        @keyframes breathe { 0%, 100% { opacity: 0.3; } 50% { opacity: 0.7; color: #00f3ff; } }
        #controls { position: absolute; bottom: 70px; width: 100%; height: 160px; pointer-events: none; padding: 0 25px; box-sizing: border-box; display: flex; justify-content: space-between; align-items: center; z-index: 10; }
        .d-pad { width: 150px; height: 150px; position: relative; pointer-events: auto; background: rgba(255,255,255,0.05); border-radius: 50%; border: 1px solid rgba(255,255,255,0.1); }
        .d-btn { position: absolute; background: rgba(255,255,255,0.15); border-radius: 8px; backdrop-filter: blur(2px); }
        .d-up { top: 10px; left: 50px; width: 50px; height: 50px; }
        .d-down { bottom: 10px; left: 50px; width: 50px; height: 50px; }
        .d-left { top: 50px; left: 10px; width: 50px; height: 50px; }
        .d-right { top: 50px; right: 10px; width: 50px; height: 50px; }
        .fire-btn { width: 90px; height: 90px; border-radius: 50%; background: linear-gradient(135deg, rgba(255, 50, 50, 0.4), rgba(150, 0, 0, 0.4)); border: 2px solid rgba(255, 80, 80, 0.8); pointer-events: auto; display: flex; justify-content: center; align-items: center; font-weight: 900; font-size: 20px; color: #fff; margin-bottom: 20px; box-shadow: 0 0 20px rgba(255,0,0,0.4); font-family: "Microsoft YaHei"; }
        .fire-btn:active { background: #f00; transform: scale(0.95); }
        button.start-btn { margin-top: 15px; padding: 12px 60px; background: #00f3ff; color: #000; font-weight: bold; font-size: 24px; cursor: pointer; border: none; clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px); transition: transform 0.2s; font-family: "Microsoft YaHei"; box-shadow: 0 0 20px rgba(0, 243, 255, 0.4); }
        button.start-btn:hover { transform: scale(1.05); background: #fff; }
    </style>
    <!-- Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="gameContainer">
    <div class="hud">
        <div id="scoreDisplay">ÂæóÂàÜ: 0</div>
        <div id="livesDisplay" style="color:#ff0080">ÁîüÂëΩ: 5</div>
        <div id="timerDisplay" style="color:#00ff00">Ë∑ùÊïåËà∞: 120s</div>
        <div id="weaponDisplay" style="color:#00f3ff">ÁÅ´Âäõ: 1Á∫ß</div>
    </div>
    
    <div id="bossHpBar" class="boss-hp-bar"><div id="bossHpFill" class="boss-hp-fill"></div></div>
    <!-- Three.js will attach here -->
    <div id="canvas-container" style="width:100%; height:100%;"></div>
    
    <div id="controls">
        <div class="d-pad">
            <div class="d-btn d-up" data-key="ArrowUp"></div>
            <div class="d-btn d-down" data-key="ArrowDown"></div>
            <div class="d-btn d-left" data-key="ArrowLeft"></div>
            <div class="d-btn d-right" data-key="ArrowRight"></div>
        </div>
        <div class="fire-btn" data-key="Space">ÂºÄÁÅ´</div>
    </div>
    
    <div id="studioLogo">Erik SOFTWARE STUDIO - 3D REMASTER</div>

    <div id="startScreen" class="overlay">
        <h1>ÁêâÁêÉ‰πãÊàò<br><span style="font-size:30px; color:#00f3ff; letter-spacing:10px;">3D VERSION</span></h1>
        <canvas id="coverCanvas" width="340" height="220" style="width:340px; height:220px; margin-bottom:20px; border-radius:10px; box-shadow: 0 0 20px #000;"></canvas>
        <button class="start-btn" onclick="Game.init()">PLAY</button>
        <p style="font-size:12px; color:#888; margin-top:10px;">Erik SOFTWARE STUDIO</p>
    </div>

    <div id="victoryScreen" class="overlay hidden">
        <h1 style="font-size: 40px; color:#ffeb3b; text-shadow: 0 0 20px orange;">ÊàòÊñóËÉúÂà©</h1>
        <p id="victoryText" style="font-size:24px; color: #fff; margin:20px 0; font-weight:bold;">ÂáªË¥•Ëà™Á©∫Ëá™Âç´ÈòüÁ¨¨ 1 Â∏àÂõ¢</p>
        <button class="start-btn" onclick="Game.nextLevel()">ÁªßÁª≠ËøΩÂáª</button>
    </div>

    <div id="finalVictoryScreen" class="overlay hidden">
        <canvas id="surrenderCanvas" width="400" height="300" style="width:100%; max-width:400px; height:auto; margin-bottom:20px; border-radius:10px;"></canvas>
        <h1 style="font-size: 48px; color:#ff3333; text-shadow: 0 0 30px red;">ÂÖ®Èù¢ËÉúÂà©</h1>
        <p style="font-size:20px; color: #fff; margin:10px 0; font-weight:bold;">Êó•Êú¨Êó†Êù°‰ª∂ÊäïÈôç</p>
        <p style="font-size:14px; color: #aaa; margin-top:20px;">10ÁßíÂêéËøîÂõûÂü∫Âú∞...</p>
    </div>

    <div id="gameOverScreen" class="overlay hidden">
        <h1 style="font-size: 40px; color:#ff3333;">‰ªªÂä°Â§±Ë¥•</h1>
        <p id="finalScore" style="font-size:28px; color: #ffeb3b; margin:20px 0;">0</p>
        <button class="start-btn" onclick="Game.restart()">ÈáçÊù•</button>
    </div>
</div>

<script>
// --- üéµ NES ACTION CHIPTUNE ENGINE (Original Code Retained) ---
const AudioSys = {
    ctx: null, isPlaying: false, theme: 'battle',
    tempo: 158, nextNoteTime: 0, step: 0, bar: 0,
    N: {
        E2: 82.41, F2: 87.31, G2: 98.00, GS2: 103.83, A2: 110.00, AS2: 116.54, B2: 123.47, 
        C3: 130.81, D3: 146.83, E3: 164.81, F3: 174.61, G3: 196.00, GS3: 207.65, A3: 220.00, AS3: 233.08, B3: 246.94,
        C4: 261.63, D4: 293.66, E4: 329.63, F4: 349.23, G4: 392.00, GS4: 415.30, A4: 440.00, AS4: 466.16, B4: 493.88,
        C5: 523.25, CS5: 554.37, D5: 587.33, E5: 659.25, F5: 698.46, G5: 783.99, GS5: 830.61, A5: 880.00, B5: 987.77,
        C6: 1046.50, E6: 1318.51, F6: 1396.91
    },
    init: function() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        if(this.ctx.state === 'suspended') this.ctx.resume();
        this.isPlaying = true; this.theme = 'battle'; this.nextNoteTime = this.ctx.currentTime + 0.1; this.step = 0; this.schedule();
    },
    setTheme: function(t) {
        this.theme = t;
        if(t === 'boss') this.tempo = 175; else if(t === 'victory') this.tempo = 140; else this.tempo = 158;
    },
    playPulse: function(freq, t, len, vol, type='square') {
        if(!this.ctx || !freq) return;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = type; o.frequency.value = freq;
        const o2 = this.ctx.createOscillator(); o2.type = 'sawtooth'; o2.frequency.value = freq; if(this.theme === 'boss') o2.detune.value = 10; const g2 = this.ctx.createGain();
        g.gain.setValueAtTime(vol, t); g.gain.exponentialRampToValueAtTime(vol * 0.1, t + len * 0.8); g.gain.linearRampToValueAtTime(0, t + len);
        g2.gain.setValueAtTime(vol * 0.3, t); g2.gain.linearRampToValueAtTime(0, t + len);
        o.connect(g); g.connect(this.ctx.destination); o2.connect(g2); g2.connect(this.ctx.destination);
        o.start(t); o.stop(t + len); o2.start(t); o2.stop(t + len);
        if(this.theme === 'battle' || this.theme === 'victory') {
            const dO = this.ctx.createOscillator(); const dG = this.ctx.createGain(); dO.type = 'square'; dO.frequency.value = freq;
            dG.gain.setValueAtTime(vol * 0.2, t + 0.15); dG.gain.exponentialRampToValueAtTime(0.001, t + 0.15 + len);
            dO.connect(dG); dG.connect(this.ctx.destination); dO.start(t+0.15); dO.stop(t+0.15+len);
        }
    },
    playTri: function(freq, t, len) {
        if(!freq) return;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = 'triangle'; o.frequency.value = freq;
        g.gain.setValueAtTime(0.3, t); g.gain.linearRampToValueAtTime(0.2, t + len * 0.9); g.gain.linearRampToValueAtTime(0, t + len);
        o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t + len);
    },
    playNoise: function(t, type) {
        const b = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate); const d = b.getChannelData(0);
        for(let i=0; i<d.length; i++) d[i] = Math.random() * 2 - 1;
        const s = this.ctx.createBufferSource(); s.buffer = b; const g = this.ctx.createGain(); const f = this.ctx.createBiquadFilter();
        if (type === 'snare') { f.type = 'highpass'; f.frequency.value = 1000; g.gain.setValueAtTime(0.3, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.1); } 
        else { f.type = 'highpass'; f.frequency.value = 5000; g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.05); }
        s.connect(f); f.connect(g); g.connect(this.ctx.destination); s.start(t);
    },
    playKick: function(t) {
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.frequency.setValueAtTime(120, t); o.frequency.exponentialRampToValueAtTime(0.01, t + 0.1);
        g.gain.setValueAtTime(0.8, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
        o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t+0.1);
    },
    playArp: function(freq, t) {
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = (this.theme === 'boss') ? 'sawtooth' : 'square'; o.frequency.value = freq;
        g.gain.setValueAtTime(0.06, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.08); o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t + 0.08);
    },
    playShoot: function() { if(!this.ctx) return; const t = this.ctx.currentTime; const o = this.ctx.createOscillator(); const g = this.ctx.createGain(); o.type = 'sawtooth'; o.frequency.setValueAtTime(1800, t); o.frequency.exponentialRampToValueAtTime(100, t + 0.12); g.gain.setValueAtTime(0.2, t); g.gain.exponentialRampToValueAtTime(0.01, t + 0.12); o.connect(g); g.connect(this.ctx.destination); o.start(t); o.stop(t + 0.12); },
    schedule: function() {
        const s16 = 60.0 / this.tempo / 4; const lookahead = 0.1;
        while(this.nextNoteTime < this.ctx.currentTime + lookahead) {
            const step = this.step; const bar = Math.floor(step / 16); const beat = step % 16; const t = this.nextNoteTime;
            if (this.theme === 'victory') {
                const bar4 = Math.floor(step/16) % 4; let root = this.N.C3;
                if(bar4 === 1) root = this.N.F3; if(bar4 === 2) root = this.N.G3; if(bar4 === 3) root = this.N.C3;
                if(step % 4 === 0) this.playTri(root, t, s16*2); if(step % 4 === 2) this.playTri(root*1.5, t, s16); 
                if(step % 4 === 0) this.playKick(t); if(step % 4 === 2) this.playNoise(t, 'snare');
                let arpNotes = [root*2, root*2.5, root*3, root*4]; this.playArp(arpNotes[step % 4], t);
                let n = null;
                if(bar4 === 0) { if(beat===0) n=this.N.C5; if(beat===4) n=this.N.E5; if(beat===8) n=this.N.G5; if(beat===12) n=this.N.C6; } 
                else if(bar4 === 1) { if(beat===0) n=this.N.F5; if(beat===4) n=this.N.A5; if(beat===8) n=this.N.C6; if(beat===12) n=this.N.F6; } 
                else if(bar4 === 2) { if(beat===0) n=this.N.G5; if(beat===4) n=this.N.B5; if(beat===8) n=this.N.D6; if(beat===12) n=this.N.G6; } 
                else { if(beat===0) n=this.N.E6; if(beat===4) n=this.N.D6; if(beat===8) n=this.N.C6; if(beat===12) n=this.N.G5; }
                if(n) this.playPulse(n, t, s16*3, 0.15);
            } else if (this.theme === 'boss') {
                const bar4 = Math.floor(step/16) % 4; let root = this.N.E2; if(bar4 === 1) root = this.N.F2; if(bar4 === 3) root = this.N.AS2; 
                this.playTri(root, t, s16); if(step % 2 === 0) this.playKick(t); if(step % 4 === 2) this.playNoise(t, 'snare');
                if(Math.random() > 0.8) this.playNoise(t, 'snare'); if(step % 2 !== 0) this.playNoise(t, 'hihat');
                let arpNotes = [root*2, root*2.37, root*2.82, root*3.36]; this.playArp(arpNotes[step % 4], t); this.playArp(arpNotes[(step+2) % 4] * 2, t + s16/2); 
                if(step % 8 === 0) this.playPulse(this.N.E6, t, s16*3, 0.15, 'sawtooth'); if(step % 4 === 2) this.playPulse(this.N.F5, t, s16, 0.1);
            } else {
                const section = Math.floor(bar / 4) % 8; let rootFreq = this.N.A2; let chordType = 'm';
                if (section < 1) { rootFreq = (step % 4 === 0) ? this.N.A2 : this.N.A3; } 
                else if (section < 3) { const p = Math.floor((bar % 4)); if(p===0) rootFreq=this.N.A2; if(p===1) rootFreq=this.N.F3/2; if(p===2) rootFreq=this.N.G3/2; if(p===3) { rootFreq=this.N.E3/2; chordType='dom'; } } 
                else if (section < 5) { const p = Math.floor((bar % 4)); if(p===0) rootFreq=this.N.F3/2; if(p===1) rootFreq=this.N.G3/2; if(p===2) rootFreq=this.N.A2; if(p===3) { rootFreq=this.N.G3/2; } } 
                else { const p = Math.floor((bar % 4)); if(p===0) rootFreq=this.N.A2; if(p===1) rootFreq=this.N.C3; if(p===2) rootFreq=this.N.D3; if(p===3) { rootFreq=this.N.E3; chordType='dom'; } }
                if(step % 4 === 0) this.playKick(t); if(step % 8 === 4) this.playNoise(t, 'snare'); if(step % 2 === 0) this.playNoise(t, 'hihat'); if(step%16 === 14 || step%16 === 15) this.playNoise(t, 'snare');
                if(step % 2 === 0) this.playTri(rootFreq, t, s16*1.5); if(beat === 14) this.playTri(rootFreq*2, t, s16); 
                let arpNotes = (chordType === 'm') ? [rootFreq*2, rootFreq*2.37, rootFreq*3, rootFreq*4] : [rootFreq*2, rootFreq*2.5, rootFreq*3, rootFreq*3.5]; 
                this.playArp(arpNotes[step % 4], t); this.playArp(arpNotes[(step+1) % 4] * 2, t + s16/2);
                let n = null; let len = s16 * 2;
                if (section === 1 || section === 2) { 
                    let phrase = bar % 4;
                    if (phrase === 0) { if(beat === 0) n = this.N.A4; if(beat === 6) n = this.N.C5; if(beat === 10) n = this.N.E5; if(beat === 12) { n = this.N.A5; len = s16*4; } } 
                    else if (phrase === 1) { if(beat === 0) n = this.N.G5; if(beat === 4) n = this.N.F5; if(beat === 8) n = this.N.E5; if(beat === 12) n = this.N.D5; } 
                    else if (phrase === 2) { if(beat === 0) n = this.N.C5; if(beat === 3) n = this.N.B4; if(beat === 6) n = this.N.C5; if(beat === 9) n = this.N.D5; if(beat === 12) n = this.N.E5; } 
                    else { if(beat === 0) n = this.N.B4; if(beat === 4) n = this.N.GS4; if(beat === 8) n = this.N.E4; if(beat === 12) n = this.N.GS4; }
                } else if (section === 3 || section === 4) { 
                     let phrase = bar % 4; if(phrase === 0) { if(beat === 0) n = this.N.C5; if(beat === 6) n = this.N.A4; if(beat === 12) n = this.N.F5; } 
                     else if (phrase === 1) { if(beat === 0) n = this.N.D5; if(beat === 6) n = this.N.B4; if(beat === 12) n = this.N.G5; } 
                     else { if(beat === 0) n = this.N.A5; if(beat === 3) n = this.N.B5; if(beat === 6) n = this.N.C6; if(beat === 9) n = this.N.B5; if(beat === 12) n = this.N.A5; }
                } else if (section >= 5) { const scale = [this.N.A4, this.N.B4, this.N.C5, this.N.D5, this.N.E5, this.N.F5, this.N.GS5, this.N.A5]; if(step % 2 === 0) { let idx = (step + bar*2) % scale.length; n = scale[idx]; len = s16; } } 
                else { if(step % 4 === 0) { n = this.N.A4; len=0.1; } if(step % 4 === 2) { n = this.N.E5; len=0.1; } }
                if(n) this.playPulse(n, t, len, 0.12);
            }
            this.nextNoteTime += s16; this.step++;
        }
        if(this.isPlaying) requestAnimationFrame(this.schedule.bind(this));
    }
};

// --- 2D ARTWORK OVERLAYS (Original Canvas code for Flags/Endings) ---
function drawChinaFlag(ctx, x, y, width) {
    let height = width * 2 / 3; ctx.fillStyle = "#DE2910"; ctx.fillRect(x, y, width, height);
    drawStar2D(ctx, x + width*0.15, y + height*0.25, width*0.09, width*0.036, "#FFDE00");
    let positions = [[0.3, 0.1], [0.36, 0.18], [0.36, 0.32], [0.3, 0.4]]; positions.forEach(pos => drawStar2D(ctx, x + width*pos[0], y + height*pos[1], width*0.03, width*0.012, "#FFDE00"));
}
function drawJapanFlag(ctx, x, y, width) {
    let height = width * 2 / 3; ctx.fillStyle = "#FFFFFF"; ctx.fillRect(x, y, width, height); ctx.fillStyle = "#BC002D"; ctx.beginPath(); ctx.arc(x + width/2, y + height/2, height*0.3, 0, Math.PI*2); ctx.fill();
}
function drawStar2D(ctx,cx,cy,r,ir,c){
    let rot=Math.PI/2*3; let x=cx; let y=cy; let step=Math.PI/5; ctx.beginPath(); ctx.moveTo(cx,cy-r);
    for(let i=0;i<5;i++){ x=cx+Math.cos(rot)*r; y=cy+Math.sin(rot)*r; ctx.lineTo(x,y); rot+=step; x=cx+Math.cos(rot)*ir; y=cy+Math.sin(rot)*ir; ctx.lineTo(x,y); rot+=step; } ctx.closePath(); ctx.fillStyle=c; ctx.fill();
}
function drawCoverArt() {
    const c = document.getElementById('coverCanvas'); const cx = c.getContext('2d'); cx.clearRect(0,0,340,220);
    const grad = cx.createLinearGradient(0,0,0,220); grad.addColorStop(0, "#001a33"); grad.addColorStop(1, "#004080"); cx.fillStyle = grad; cx.fillRect(0,0,340,220);
    drawChinaFlag(cx, 10, 20, 80); drawJapanFlag(cx, 250, 20, 80);
    cx.fillStyle = "#fff"; cx.font = "italic 900 40px Arial"; cx.shadowColor="black"; cx.shadowBlur=10; cx.textAlign = "center"; cx.fillText("VS", 170, 180); cx.shadowBlur=0;
}
function drawSurrenderArt() {
    const c = document.getElementById('surrenderCanvas'); const cx = c.getContext('2d'); cx.clearRect(0,0,400,300);
    const grad = cx.createLinearGradient(0,0,0,300); grad.addColorStop(0, "#222"); grad.addColorStop(1, "#444"); cx.fillStyle = grad; cx.fillRect(0,0,400,300);
    cx.save(); cx.translate(200, 150); cx.globalAlpha = 0.4; cx.fillStyle = "#ddd"; cx.fillRect(-120, -80, 240, 160); cx.fillStyle = "#800"; cx.beginPath(); cx.arc(0, 0, 50, 0, Math.PI*2); cx.fill(); cx.restore();
    cx.save(); cx.translate(200, 150); cx.rotate(0.1); cx.fillStyle = "#fff"; cx.shadowColor = "#000"; cx.shadowBlur = 20; cx.beginPath(); cx.moveTo(-10, -100); cx.lineTo(-10, 100); cx.strokeStyle="#666"; cx.lineWidth=5; cx.stroke(); cx.fillRect(-8, -90, 140, 100); 
    cx.fillStyle = "#ccc"; cx.font = "20px Arial"; cx.fillText("SURRENDER", 10, -30); cx.restore();
}
setTimeout(drawCoverArt, 100);

// --- 3D ENGINE & GAME LOGIC ---

// Globals
let scene, camera, renderer;
let playerMesh, oceanMesh;
const bullets = [], enemies = [], ships = [], shipBullets = [], powerups = [], particles = [];
let spawnTimer=0, shipTimer=0, boss=null, lastTime=0;
const keys = {};
const scoreEl = document.getElementById('scoreDisplay');
const timerEl = document.getElementById('timerDisplay');
const weaponEl = document.getElementById('weaponDisplay');
const livesEl = document.getElementById('livesDisplay');
const bossHpBar = document.getElementById('bossHpBar');
const bossHpFill = document.getElementById('bossHpFill');

function to3DX(x) { return (x - 240) * 0.1; }
function to3DZ(y) { return (y - 400) * 0.1; }
function mapCoord(x, y) { return { x: (x - 240) * 0.1, z: (y - 400) * 0.1 }; }

// Simple Mats for enemies
const matEnemy = new THREE.MeshPhongMaterial({color: 0x455a64});
const matEnemyMark = new THREE.MeshBasicMaterial({color: 0xd32f2f});
const matBulletPlayer = new THREE.MeshBasicMaterial({color: 0x00ccff});
const matBulletBoss = new THREE.MeshBasicMaterial({color: 0xff0000});
const matBulletShip = new THREE.MeshBasicMaterial({color: 0xffaa00});
const matShip = new THREE.MeshPhongMaterial({color: 0x546e7a});
const matPowerup = new THREE.MeshStandardMaterial({color: 0xffff00, emissive: 0x555500});

// Init ThreeJS
function init3D() {
    const container = document.getElementById('canvas-container');
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x001a33);
    scene.fog = new THREE.Fog(0x001a33, 40, 90);

    camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 1, 500);
    camera.position.set(0, 50, 30);
    camera.lookAt(0, 0, -5);

    renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    const ambientLight = new THREE.AmbientLight(0x404040, 1.5); 
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(-20, 50, 20);
    dirLight.castShadow = true;
    scene.add(dirLight);

    const planeGeo = new THREE.PlaneGeometry(100, 200, 20, 20);
    const planeMat = new THREE.MeshStandardMaterial({ color: 0x003366, wireframe: true, transparent: true, opacity: 0.3 });
    oceanMesh = new THREE.Mesh(planeGeo, planeMat);
    oceanMesh.rotation.x = -Math.PI / 2;
    oceanMesh.position.y = -10;
    scene.add(oceanMesh);

    // Load the realistic J-20 model
    playerMesh = createJ20Model();
    scene.add(playerMesh);
    
    window.addEventListener('resize', onWindowResize, false);
}

function onWindowResize() {
    const container = document.getElementById('gameContainer');
    camera.aspect = container.clientWidth / container.clientHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(container.clientWidth, container.clientHeight);
}

// --- REALISTIC J-20 MODEL CONTRUCTION ---
function createJ20Model() {
    const j20Group = new THREE.Group();

    // High Quality Materials
    const fuselageColor = 0x37474f; // Dark Blue-Grey Stealth
    const canopyColor = 0xc0a040; // Gold/Orange tint
    const engineColor = 0x111111;

    const matBody = new THREE.MeshStandardMaterial({ color: fuselageColor, roughness: 0.4, metalness: 0.3, side: THREE.DoubleSide });
    const matCanopy = new THREE.MeshPhongMaterial({ color: canopyColor, shininess: 120, opacity: 0.9, transparent: true });
    const matEngine = new THREE.MeshStandardMaterial({ color: engineColor, roughness: 0.7 });
    const matGlow = new THREE.MeshBasicMaterial({ color: 0xff3300 });

    // 1. Nose Section (Diamond Chined Cross-section)
    const noseGeo = new THREE.BufferGeometry();
    const noseVertices = new Float32Array([
        // Top Half
        0,0,-2.8,  0.6,0.2,-1.0,  -0.6,0.2,-1.0,
        0,0,-2.8,  0,0.5,-1.0,    0.6,0.2,-1.0,
        0,0,-2.8,  -0.6,0.2,-1.0, 0,0.5,-1.0,
        // Bottom Half
        0,0,-2.8,  0.6,0.2,-1.0,  0,-0.2,-1.0,
        0,0,-2.8,  0,-0.2,-1.0,   -0.6,0.2,-1.0,
        0,0,-2.8,  -0.6,0.2,-1.0, 0,-0.2,-1.0,
        0,0,-2.8,  0,-0.2,-1.0,   0.6,0.2,-1.0
    ]);
    noseGeo.setAttribute('position', new THREE.BufferAttribute(noseVertices, 3));
    noseGeo.computeVertexNormals();
    const nose = new THREE.Mesh(noseGeo, matBody);
    j20Group.add(nose);

    // 2. Cockpit Canopy (Bubble)
    const canopyGeo = new THREE.SphereGeometry(0.35, 16, 16);
    const canopy = new THREE.Mesh(canopyGeo, matCanopy);
    canopy.scale.set(1, 0.7, 2);
    canopy.position.set(0, 0.4, -1.2);
    j20Group.add(canopy);

    // 3. Main Fuselage
    const bodyGeo = new THREE.BoxGeometry(1.4, 0.6, 4.0);
    const body = new THREE.Mesh(bodyGeo, matBody);
    body.position.set(0, 0, 1.0);
    j20Group.add(body);

    // 4. Intakes (DSI)
    const intakeGeo = new THREE.BoxGeometry(0.7, 0.6, 2.5);
    const intakeL = new THREE.Mesh(intakeGeo, matBody); intakeL.position.set(-1.05, 0, 0.5);
    const intakeR = new THREE.Mesh(intakeGeo, matBody); intakeR.position.set(1.05, 0, 0.5);
    j20Group.add(intakeL); j20Group.add(intakeR);
    // DSI Bumps (Visual approximation)
    const bumpGeo = new THREE.SphereGeometry(0.3, 8, 8);
    const bL = new THREE.Mesh(bumpGeo, matBody); bL.scale.set(1, 1, 2); bL.position.set(-1.05, 0, -0.8);
    const bR = new THREE.Mesh(bumpGeo, matBody); bR.scale.set(1, 1, 2); bR.position.set(1.05, 0, -0.8);
    j20Group.add(bL); j20Group.add(bR);

    // 5. Canards (Forward Swept Control Surfaces)
    const canardGeo = new THREE.BufferGeometry();
    const canardVerts = new Float32Array([
         0.7,0.1,-0.8,   2.0,0.2,-1.6,   0.7,0.1,-1.8, // Top
         0.7,0.05,-0.8,  2.0,0.15,-1.6,  0.7,0.05,-1.8 // Bottom
    ]);
    canardGeo.setAttribute('position', new THREE.BufferAttribute(canardVerts, 3));
    canardGeo.computeVertexNormals();
    const cL = new THREE.Mesh(canardGeo, matBody); cL.scale.x = -1; // Mirror Left
    const cR = new THREE.Mesh(canardGeo, matBody);
    j20Group.add(cL); j20Group.add(cR);

    // 6. Main Delta Wings
    const mainWingGeo = new THREE.BufferGeometry();
    const mwVerts = new Float32Array([
         // Right Wing
         0.7,0.1,-0.2,   3.5,0.0,1.8,   0.7,0.1,2.6, // Main Delta
         3.5,0.0,1.8,    3.5,0.0,2.4,   0.7,0.1,2.6, // Clipped Tip/Trailing
         // Left Wing
         -0.7,0.1,-0.2,  -0.7,0.1,2.6,  -3.5,0.0,1.8,
         -3.5,0.0,1.8,   -0.7,0.1,2.6,  -3.5,0.0,2.4
    ]);
    mainWingGeo.setAttribute('position', new THREE.BufferAttribute(mwVerts, 3));
    mainWingGeo.computeVertexNormals();
    const wings = new THREE.Mesh(mainWingGeo, matBody);
    j20Group.add(wings);

    // 7. Vertical Stabilizers (Canted Out V-Tail)
    const tailGeo = new THREE.BufferGeometry();
    const tailVerts = new Float32Array([
        0,0,0,  0,1.5,1.2,  0,0,1.8 // Simple triangle fin
    ]);
    tailGeo.setAttribute('position', new THREE.BufferAttribute(tailVerts, 3));
    tailGeo.computeVertexNormals();
    const tL = new THREE.Mesh(tailGeo, matBody);
    tL.position.set(-0.8, 0.3, 1.5); tL.rotation.z = -0.4; // Cant Left
    const tR = new THREE.Mesh(tailGeo, matBody);
    tR.position.set(0.8, 0.3, 1.5); tR.rotation.z = 0.4; // Cant Right
    j20Group.add(tL); j20Group.add(tR);

    // 8. Ventral Fins (Underneath)
    const vFinGeo = new THREE.BufferGeometry();
    const vFinVerts = new Float32Array([ 0,0,0,  0,-0.8,0.5,  0,0,1.0 ]);
    vFinGeo.setAttribute('position', new THREE.BufferAttribute(vFinVerts, 3));
    vFinGeo.computeVertexNormals();
    const vfL = new THREE.Mesh(vFinGeo, matBody);
    vfL.position.set(-0.9, -0.2, 2.0); vfL.rotation.z = 0.5; 
    const vfR = new THREE.Mesh(vFinGeo, matBody);
    vfR.position.set(0.9, -0.2, 2.0); vfR.rotation.z = -0.5;
    j20Group.add(vfL); j20Group.add(vfR);

    // 9. Engines (Serrated Nozzles)
    const nozzleGeo = new THREE.CylinderGeometry(0.35, 0.45, 0.8, 12, 1, true);
    const nL = new THREE.Mesh(nozzleGeo, matEngine);
    nL.rotation.x = Math.PI/2; nL.position.set(-0.6, 0, 3.4);
    const nR = new THREE.Mesh(nozzleGeo, matEngine);
    nR.rotation.x = Math.PI/2; nR.position.set(0.6, 0, 3.4);
    j20Group.add(nL); j20Group.add(nR);
    
    // Afterburner
    const glowGeo = new THREE.ConeGeometry(0.3, 1.5, 8);
    const gL = new THREE.Mesh(glowGeo, matGlow);
    gL.rotation.x = Math.PI/2; gL.position.set(-0.6, 0, 4.0);
    const gR = new THREE.Mesh(glowGeo, matGlow);
    gR.rotation.x = Math.PI/2; gR.position.set(0.6, 0, 4.0);
    j20Group.add(gL); j20Group.add(gR);

    return j20Group;
}

function createEnemyPlane() {
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.ConeGeometry(1, 4, 4), matEnemy);
    body.rotation.x = Math.PI/2; 
    body.scale.set(1,1,0.5); 
    group.add(body);
    const marks = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 0.5), matEnemyMark);
    marks.position.z = 0.5;
    group.add(marks);
    return group;
}

function createDestroyer() {
    const group = new THREE.Group();
    const hull = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 6), matShip);
    group.add(hull);
    const tower = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 2), matShip);
    tower.position.set(0, 1, -0.5);
    group.add(tower);
    return group;
}

function createCarrierBoss() {
    const group = new THREE.Group();
    const deck = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 20), matEnemy);
    group.add(deck);
    const tower = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 4), matShip);
    tower.position.set(2, 2, 0);
    group.add(tower);
    return group;
}
function createSubmarineBoss() {
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.CylinderGeometry(2.5, 2.5, 22, 16), new THREE.MeshPhongMaterial({color:0x1c2331}));
    body.rotation.x = Math.PI/2;
    group.add(body);
    const tower = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 6), matShip);
    tower.position.set(0, 2, -2);
    group.add(tower);
    return group;
}
function createE767Boss() {
    const group = new THREE.Group();
    const body = new THREE.Mesh(new THREE.CylinderGeometry(2, 1, 20, 8), new THREE.MeshPhongMaterial({color:0xcfd8dc}));
    body.rotation.x = Math.PI/2;
    group.add(body);
    const wings = new THREE.Mesh(new THREE.BoxGeometry(24, 0.5, 4), new THREE.MeshPhongMaterial({color:0xcfd8dc}));
    wings.position.z = 2;
    group.add(wings);
    const dome = new THREE.Mesh(new THREE.CylinderGeometry(3, 3, 1, 16), new THREE.MeshPhongMaterial({color:0x263238}));
    dome.position.set(0, 3, 2);
    group.add(dome);
    return group;
}

// Input Handling
document.querySelectorAll('.d-btn, .fire-btn').forEach(btn => {
    btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[btn.dataset.key] = true; btn.style.transform='scale(0.9)'; });
    btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[btn.dataset.key] = false; btn.style.transform='scale(1)'; });
});
window.onkeydown = e => keys[e.code] = true;
window.onkeyup = e => keys[e.code] = false;

// Game Object
const Game = {
    active: false, paused: false, score: 0, kills: 0, weaponLevel: 1, gameTime: 0, divisionCount: 1, bossMode: false,
    bgOffset: 0,
    init: function() { 
        if(!scene) init3D();
        AudioSys.init(); 
        this.start(); 
    },
    start: function() {
        document.getElementById('startScreen').classList.add('hidden');
        document.getElementById('gameOverScreen').classList.add('hidden');
        document.getElementById('victoryScreen').classList.add('hidden');
        document.getElementById('finalVictoryScreen').classList.add('hidden');
        bossHpBar.style.display = 'none';
        AudioSys.setTheme('battle');
        this.active = true; this.paused = false; this.bossMode = false;
        this.score = 0; this.kills = 0; this.weaponLevel = 1; this.gameTime = 0; this.divisionCount = 1;
        this.updateUI(); player.reset();
        
        bullets.forEach(b => scene.remove(b.mesh)); bullets.length = 0;
        enemies.forEach(e => scene.remove(e.mesh)); enemies.length = 0;
        ships.forEach(s => scene.remove(s.mesh)); ships.length = 0;
        shipBullets.forEach(b => scene.remove(b.mesh)); shipBullets.length = 0;
        powerups.forEach(p => scene.remove(p.mesh)); powerups.length = 0;
        particles.forEach(p => scene.remove(p.mesh)); particles.length = 0;
        if(boss && boss.mesh) scene.remove(boss.mesh); boss = null;

        lastTime = performance.now();
        requestAnimationFrame(loop);
    },
    restart: function() { this.start(); },
    nextLevel: function() {
        document.getElementById('victoryScreen').classList.add('hidden');
        this.paused = false; this.gameTime = 0; this.bossMode = false;
        AudioSys.setTheme('battle');
        if(boss && boss.mesh) scene.remove(boss.mesh);
        boss = null; bossHpBar.style.display = 'none';
        lastTime = performance.now();
        requestAnimationFrame(loop);
    },
    winStage: function() {
        if (this.divisionCount === 3) { this.finalVictory(); return; }
        this.paused = true; this.divisionCount++;
        document.getElementById('victoryText').innerText = `ÂáªË¥•Ëà™Á©∫Ëá™Âç´ÈòüÁ¨¨ ${this.divisionCount-1} Â∏àÂõ¢`;
        document.getElementById('victoryScreen').classList.remove('hidden');
    },
    finalVictory: function() {
        this.paused = true;
        document.getElementById('finalVictoryScreen').classList.remove('hidden');
        AudioSys.setTheme('victory');
        drawSurrenderArt();
        setTimeout(() => { Game.resetToTitle(); }, 10000);
    },
    resetToTitle: function() {
        document.getElementById('finalVictoryScreen').classList.add('hidden');
        document.getElementById('startScreen').classList.remove('hidden');
        this.active = false;
        drawCoverArt();
    },
    over: function() {
        this.active = false;
        document.getElementById('finalScore').innerText = "ÊúÄÁªàÂæóÂàÜ: " + this.score;
        document.getElementById('gameOverScreen').classList.remove('hidden');
    },
    updateUI: function() {
        scoreEl.innerText = "ÂæóÂàÜ: " + this.score;
        livesEl.innerText = "ÁîüÂëΩ: " + player.lives;
        let timeLeft = Math.max(0, 120 - Math.floor(this.gameTime));
        timerEl.innerText = this.bossMode ? "BOSS Áé∞Ë∫´!" : `Ë∑ùÊïåËà∞: ${timeLeft}s`;
        timerEl.style.color = this.bossMode ? "#ff0000" : "#00ff00";
        let lvText = this.weaponLevel + "Á∫ß"; if(this.weaponLevel === 6) lvText = "MAX";
        weaponEl.innerText = "ÁÅ´Âäõ: " + lvText;
    }
};

class Boss {
    constructor() { 
        this.logicX = 240; this.logicY = -150; 
        this.maxHp = 500+(Game.divisionCount*200); this.hp = this.maxHp; 
        this.state = 'entering'; this.dir = 1; this.shootTimer = 0; 
        if(Game.divisionCount === 2) this.mesh = createSubmarineBoss();
        else if(Game.divisionCount === 3) this.mesh = createE767Boss();
        else this.mesh = createCarrierBoss();
        scene.add(this.mesh);
    }
    update(dt) {
        if(this.state === 'entering') { this.logicY += 50 * dt; if(this.logicY >= 80) this.state = 'fight'; } 
        else {
            this.logicX += 40 * this.dir * dt; 
            if(this.logicX > 480 - 60) this.dir = -1; if(this.logicX < 60) this.dir = 1;
            this.shootTimer -= dt; 
            if(this.shootTimer <= 0) { 
                for(let i=-2; i<=2; i++) spawnEnemyBullet(this.logicX, this.logicY+80, i*100, 300, true); 
                this.shootTimer = 1.2; 
            }
        }
        const pos = mapCoord(this.logicX, this.logicY);
        this.mesh.position.set(pos.x, 0, pos.z);
        this.mesh.position.y = Math.sin(Date.now()/500) * 1; 
        this.mesh.rotation.z = Math.sin(Date.now()/1000) * 0.05;
    }
}

const player={
    logicX:0, logicY:0, speed:350, cooldown:0, lives:5, invuln:0,
    reset:function(){ this.logicX=240; this.logicY=680; this.lives=5; this.invuln=0; playerMesh.position.set(0,0,28); },
    update:function(dt){
        if(this.invuln>0)this.invuln-=dt;
        let movedX = 0;
        if(keys.ArrowLeft && this.logicX>25) { this.logicX-=this.speed*dt; movedX = -1; }
        if(keys.ArrowRight && this.logicX<455) { this.logicX+=this.speed*dt; movedX = 1; }
        if(keys.ArrowUp && this.logicY>50) this.logicY-=this.speed*dt;
        if(keys.ArrowDown && this.logicY<750) this.logicY+=this.speed*dt;
        if(this.cooldown>0)this.cooldown-=dt;
        if(keys.Space&&this.cooldown<=0)this.shoot();

        const pos = mapCoord(this.logicX, this.logicY);
        playerMesh.position.set(pos.x, 0, pos.z);
        playerMesh.rotation.z = -movedX * 0.4;
        playerMesh.rotation.x = (keys.ArrowUp ? -0.1 : (keys.ArrowDown ? 0.1 : 0));
        
        if(this.invuln > 0) playerMesh.visible = Math.floor(Date.now()/100)%2===0;
        else playerMesh.visible = true;
    },
    hit:function(){
        if(this.invuln>0)return;
        this.lives--; Game.weaponLevel=1; 
        createExplosion(this.logicX, this.logicY, 50, 0xff0000); 
        Game.updateUI();
        if(this.lives<=0) Game.over(); else this.invuln=2;
    },
    shoot:function(){
        AudioSys.playShoot();
        const x=this.logicX, y=this.logicY-20, speed=-800; 
        this.cooldown=(Game.weaponLevel>=4?0.12:0.15); if(Game.weaponLevel===6)this.cooldown=0.08;
        
        const spawnB = (ox, oy, vx, vy, t) => {
            const geo = new THREE.BoxGeometry(0.5, 0.5, 2);
            const m = new THREE.Mesh(geo, t===4 ? matBulletBoss : (t===3?matBulletShip:matBulletPlayer));
            scene.add(m);
            bullets.push({x:ox, y:oy, vx:vx, vy:vy, type:t, mesh:m});
        };

        if(Game.weaponLevel===1) spawnB(x,y,0,speed,1);
        else if(Game.weaponLevel===2){ spawnB(x-10,y,0,speed,1); spawnB(x+10,y,0,speed,1); }
        else if(Game.weaponLevel===3){ spawnB(x,y-5,0,speed,1); spawnB(x-15,y,-150,speed*0.9,1); spawnB(x+15,y,150,speed*0.9,1); }
        else if(Game.weaponLevel===4){ spawnB(x-8,y-5,0,speed,2); spawnB(x+8,y-5,0,speed,2); spawnB(x-25,y,-200,speed*0.9,2); spawnB(x+25,y,200,speed*0.9,2); }
        else if(Game.weaponLevel===5){ spawnB(x,y-10,0,speed,3); spawnB(x-15,y-5,-100,speed,3); spawnB(x+15,y-5,100,speed,3); spawnB(x-35,y,-300,speed*0.9,3); spawnB(x+35,y,300,speed*0.9,3); }
        else if(Game.weaponLevel===6){ spawnB(x,y-10,0,-1200,4); spawnB(x-12,y-5,-50,-1200,4); spawnB(x+12,y-5,50,-1200,4); spawnB(x-30,y,-300,-1000,4); spawnB(x+30,y,300,-1000,4); spawnB(x-50,y+10,-600,-900,4); spawnB(x+50,y+10,600,-900,4); }
    }
};

function spawnEnemyBullet(x, y, vx, vy, isBoss) {
    const geo = new THREE.SphereGeometry(isBoss?0.8:0.5, 8, 8);
    const m = new THREE.Mesh(geo, isBoss?matBulletBoss:matBulletShip);
    const pos = mapCoord(x, y);
    m.position.set(pos.x, 0, pos.z);
    scene.add(m);
    shipBullets.push({x:x, y:y, vx:vx, vy:vy, isBoss:isBoss, mesh:m});
}

function spawnPowerup(x, y) {
    const geo = new THREE.BoxGeometry(2, 2, 2);
    const m = new THREE.Mesh(geo, matPowerup);
    const pos = mapCoord(x, y);
    m.position.set(pos.x, 0, pos.z);
    scene.add(m);
    powerups.push({x:x, y:y, rot:0, mesh:m});
}

function createExplosion(x, y, count, colorHex) {
    for(let i=0; i<count/2; i++) {
        const geo = new THREE.BoxGeometry(0.5,0.5,0.5);
        const mat = new THREE.MeshBasicMaterial({color: colorHex});
        const m = new THREE.Mesh(geo, mat);
        const pos = mapCoord(x, y);
        m.position.set(pos.x + (Math.random()-0.5)*2, 0, pos.z + (Math.random()-0.5)*2);
        scene.add(m);
        particles.push({
            mesh: m, 
            vx: (Math.random()-0.5)*40, 
            vy: (Math.random()-0.5)*40, 
            vz: (Math.random()-0.5)*40, 
            life: 1.0 
        });
    }
}

function loop(timestamp) {
    if(!Game.active || Game.paused) return;
    let dt = (timestamp - lastTime) / 1000; lastTime = timestamp; if(dt > 0.1) dt = 0.1;

    Game.bgOffset += 20 * dt;
    oceanMesh.position.z = (Game.bgOffset % 10) + 10;
    
    if(!Game.bossMode) { 
        Game.gameTime += dt; Game.updateUI(); 
        if(Game.gameTime >= 120) { Game.bossMode = true; boss = new Boss(); bossHpBar.style.display = 'block'; enemies.forEach(e=>scene.remove(e.mesh)); enemies.length=0; ships.forEach(s=>scene.remove(s.mesh)); ships.length=0; AudioSys.setTheme('boss'); } 
    }
    if(boss) { 
        boss.update(dt); 
        bossHpFill.style.width = (boss.hp/boss.maxHp*100)+"%"; 
        for(let j=bullets.length-1; j>=0; j--) { 
            if(Math.abs(boss.logicX-bullets[j].x)<50 && Math.abs(boss.logicY-bullets[j].y)<90) { 
                scene.remove(bullets[j].mesh); bullets.splice(j,1); boss.hp-=2; 
                createExplosion(boss.logicX+(Math.random()-0.5)*60, boss.logicY+(Math.random()-0.5)*100, 3, 0xffffff); 
                if(boss.hp<=0) { 
                    createExplosion(boss.logicX, boss.logicY, 80, 0xffaa00); 
                    Game.score+=5000; Game.winStage(); return; 
                } 
            } 
        } 
    }

    if(!Game.bossMode) { 
        shipTimer-=dt; 
        if(shipTimer<=0){
            const sMesh = createDestroyer();
            const sx = Math.random()*(480-40)+20;
            scene.add(sMesh);
            ships.push({x:sx, y:-80, hp:5, mesh:sMesh}); 
            shipTimer=5;
        } 
        for(let i=ships.length-1; i>=0; i--) { 
            let s=ships[i]; s.y+=50*dt; 
            const pos = mapCoord(s.x, s.y);
            s.mesh.position.set(pos.x, -1, pos.z);
            if(Math.random()<0.01) spawnEnemyBullet(s.x, s.y, (player.logicX-s.x)*0.5, -300, false);
            for(let j=bullets.length-1; j>=0; j--) { 
                if(Math.abs(s.x-bullets[j].x)<15 && Math.abs(s.y-bullets[j].y)<40){ 
                    scene.remove(bullets[j].mesh); bullets.splice(j,1); s.hp--; 
                    createExplosion(s.x, s.y, 5, 0xffffff);
                    if(s.hp<=0){
                        createExplosion(s.x, s.y, 40, 0xffaa00); 
                        scene.remove(s.mesh); ships.splice(i,1); Game.score+=50;
                    } break; 
                } 
            } 
            if(s.y>850) { scene.remove(s.mesh); ships.splice(i,1); }
        } 
    }
    
    for(let i=shipBullets.length-1; i>=0; i--) { 
        let b=shipBullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; 
        const pos = mapCoord(b.x, b.y);
        b.mesh.position.set(pos.x, 0, pos.z);
        if(Math.hypot(b.x-player.logicX, b.y-player.logicY)<20) { 
            player.hit(); 
            if(player.lives>0) { scene.remove(b.mesh); shipBullets.splice(i,1); } 
        } else if(b.y<-50||b.x<0||b.x>480||b.y>850) { 
            scene.remove(b.mesh); shipBullets.splice(i,1); 
        } 
    }

    player.update(dt);
    
    for(let i=bullets.length-1; i>=0; i--) { 
        let b=bullets[i]; b.x+=b.vx*dt; b.y+=b.vy*dt; 
        const pos = mapCoord(b.x, b.y);
        b.mesh.position.set(pos.x, 0, pos.z);
        if(b.y<-50) { scene.remove(b.mesh); bullets.splice(i,1); } 
    }
    
    if(!Game.bossMode) { 
        spawnTimer-=dt; 
        let rate=0.8-(Math.min(Game.score,5000)/10000); 
        if(spawnTimer<=0){
            const eMesh = createEnemyPlane();
            const ex = Math.random()*(480-60)+30;
            scene.add(eMesh);
            enemies.push({x:ex, y:-60, speed:150+Math.random()*200, mesh:eMesh}); 
            spawnTimer=Math.max(0.3,rate);
        } 
        for(let i=enemies.length-1; i>=0; i--) { 
            let e=enemies[i]; e.y+=e.speed*dt; 
            const pos = mapCoord(e.x, e.y);
            e.mesh.position.set(pos.x, 0, pos.z);
            let hit=false; 
            if(Math.random() < 0.005) spawnEnemyBullet(e.x, e.y+10, 0, 250, false);
            for(let j=bullets.length-1; j>=0; j--){
                if(Math.abs(e.x-bullets[j].x)<25 && Math.abs(e.y-bullets[j].y)<25){
                    hit=true; scene.remove(bullets[j].mesh); bullets.splice(j,1); 
                    killEnemy(e.x, e.y, i); break;
                }
            } 
            if(!hit && Math.hypot(e.x-player.logicX, e.y-player.logicY)<40){ 
                player.hit(); scene.remove(e.mesh); enemies.splice(i,1); 
            } else if(e.y>850) { 
                scene.remove(e.mesh); enemies.splice(i,1); 
            } 
        } 
    }
    
    for(let i=powerups.length-1; i>=0; i--){
        let p=powerups[i]; p.y+=120*dt; 
        p.mesh.rotation.y += 3*dt; p.mesh.rotation.x += 2*dt;
        const pos = mapCoord(p.x, p.y);
        p.mesh.position.set(pos.x, 0, pos.z);
        if(Math.hypot(p.x-player.logicX, p.y-player.logicY)<40){
            upgradePlayer(); scene.remove(p.mesh); powerups.splice(i,1);
        } else if(p.y>850) { 
            scene.remove(p.mesh); powerups.splice(i,1); 
        }
    }
    
    for(let i=particles.length-1; i>=0; i--){
        let p=particles[i]; 
        p.mesh.position.x += p.vx*dt;
        p.mesh.position.z += p.vy*dt;
        p.mesh.position.y += p.vz*dt;
        p.life-=dt; p.mesh.material.opacity = p.life;
        p.mesh.scale.setScalar(p.life);
        if(p.life<=0) { scene.remove(p.mesh); particles.splice(i,1); }
    }

    renderer.render(scene, camera);
    requestAnimationFrame(loop);
}

function killEnemy(x,y,idx){
    createExplosion(x,y,15, 0xff9800); 
    Game.score+=10; Game.kills++; Game.updateUI(); 
    if(Game.kills%15===0) spawnPowerup(x, y);
    scene.remove(enemies[idx].mesh);
    enemies.splice(idx,1);
}
function upgradePlayer(){
    if(Game.weaponLevel<6){ Game.weaponLevel++; showFloatText(player.logicX, player.logicY,"ÁÅ´ÂäõÂçáÁ∫ß!","#00ff00"); }
    else{ Game.score+=500; showFloatText(player.logicX, player.logicY,"MAX GUN","#ff0000"); }
    AudioSys.playShoot(); Game.updateUI();
}
function showFloatText(x,y,t,c){
    let d=document.createElement('div'); d.innerText=t; d.style.position='absolute'; 
    d.style.left=(x/480*100)+'%'; d.style.top=(y/800*100)+'%'; 
    d.style.fontWeight='bold'; d.style.textShadow='0 0 5px black'; d.style.pointerEvents='none'; d.style.transition='all 1s ease-out';
    d.style.fontSize='20px'; d.style.color=c; 
    document.getElementById('gameContainer').appendChild(d);
    setTimeout(()=>{d.style.transform='translateY(-50px)'; d.style.opacity=0;},50); setTimeout(()=>d.remove(),1000);
}
</script>
</body>
</html>